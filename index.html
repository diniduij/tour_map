<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trenton 3D Tour Map</title>
  
  <!-- CesiumJS Library -->
  <script src="https://ajax.googleapis.com/ajax/libs/cesiumjs/1.105/Build/Cesium/Cesium.js"></script>
  <link href="https://ajax.googleapis.com/ajax/libs/cesiumjs/1.105/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }

    #sidePanel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(25, 25, 25, 0.9);
      padding: 15px;
      border-radius: 8px;
      z-index: 10;
      color: white;
      font-family: 'Karla', sans-serif;
      width: 220px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }

    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 6px;
      color: white;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
    }

    .layer-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    .layer-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .section-title {
      padding: 10px 0;
      font-size: 11px;
      color: #4fc3f7;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .grade-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 6px;
      color: white;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      font-size: 13px;
      margin-left: 16px;
    }

    .grade-toggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    .grade-toggle input[type="checkbox"] {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .color-swatch {
      width: 18px;
      height: 18px;
      border-radius: 2px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    #featurePopup {
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: 400px;
      background: rgba(25, 25, 25, 0.98);
      padding: 20px;
      z-index: 20;
      color: white;
      font-family: 'Karla', sans-serif;
      overflow-y: auto;
      box-shadow: -4px 0 15px rgba(0, 0, 0, 0.7);
      display: none;
      border-left: 1px solid rgba(255, 255, 255, 0.2);
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }

    #featurePopup.visible {
      display: block;
      transform: translateX(0);
    }

    #featurePopup .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 10px;
      background-color: rgba(60, 60, 60, 0.5);
      padding: 10px;
      margin: -20px -20px 15px -20px;
      padding-bottom: 10px;
    }

    #featurePopup .popup-title {
      font-size: 18px;
      font-weight: bold;
      color: #4fc3f7;
    }

    #featurePopup .close-btn {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
    }

    #featurePopup .close-btn:hover {
      color: #4fc3f7;
    }

    #featurePopup .popup-content {
      font-size: 13px;
      line-height: 1.6;
    }

    #featurePopup .popup-content p {
      margin: 8px 0;
    }

    #featurePopup .popup-content strong {
      color: #4fc3f7;
    }

    /* Reset view button (top-right) */
    #resetViewBtn {
      position: fixed;
      top: 50px;
      right: 10px;
      z-index: 12;
      background: rgba(40,40,40,0.9);
      color: #ffffff;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Karla', sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    #resetViewBtn:hover {
      background: rgba(64,64,64,0.95);
      color: #4fc3f7;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <div id="featurePopup">
    <div class="popup-header">
      <div class="popup-title" id="popupTitle">Feature Details</div>
      <button class="close-btn" id="closePopupBtn">√ó</button>
    </div>
    <div class="popup-content" id="popupContent"></div>
  </div>

  <div id="sidePanel">
    <div class="section-title">üìç Layers</div>
    <label class="layer-toggle">
      <input type="checkbox" id="toggleHotspots" checked>
      üìç Hotspots
    </label>
    <label class="layer-toggle">
      <input type="checkbox" id="toggleNeighborhoods">
      üèòÔ∏è Neighborhoods
    </label>
    <label class="layer-toggle">
      <input type="checkbox" id="toggleRedlining">
      üó∫Ô∏è HOLC Redlining
    </label>
    <div id="gradesContainer" style="margin-left: 8px;">
      <label class="grade-toggle">
        <div class="color-swatch" style="background-color: #76a865;"></div>
        <input type="checkbox" id="toggleGradeA" checked data-grade="A">
        <span>A: Best</span>
      </label>
      <label class="grade-toggle">
        <div class="color-swatch" style="background-color: #7cb5bd;"></div>
        <input type="checkbox" id="toggleGradeB" checked data-grade="B">
        <span>B: Still Desirable</span>
      </label>
      <label class="grade-toggle">
        <div class="color-swatch" style="background-color: #ffff00;"></div>
        <input type="checkbox" id="toggleGradeC" checked data-grade="C">
        <span>C: Declining</span>
      </label>
      <label class="grade-toggle">
        <div class="color-swatch" style="background-color: #d9838d;"></div>
        <input type="checkbox" id="toggleGradeD" checked data-grade="D">
        <span>D: Hazardous</span>
      </label>
      <label class="grade-toggle">
        <div class="color-swatch" style="background-color: #808080;"></div>
        <input type="checkbox" id="toggleGradeOther" data-grade="Other">
        <span>Other: Commercial/Industrial</span>
      </label>
    </div>
    <label class="layer-toggle">
      <input type="checkbox" id="toggleGoogle3D" checked>
      üè¢ Google 3D Tiles
    </label>
  </div>

  <button id="resetViewBtn" title="Reset camera view">‚ü≤ Reset View</button>

  <script>
    /**
     * Trenton 3D Tour Map
     * =====================
     * A CesiumJS application displaying Google Photorealistic 3D tiles
     * over Trenton, NJ with an interactive layer toggle UI.
     *
     * Dependencies:
     * - CesiumJS 1.105+
     * - Cesium Ion token
     * - Google 3D Tiles API token
     */

    // Cesium Ion Access Token for terrain and resources
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0YzEzOTJiOS04ZDk5LTQ2YTgtYTVlYS1iOWFkMjA5NWYzMTUiLCJpZCI6Mzg4NDA0LCJpYXQiOjE3NzA1NTA4MjF9.uWOUlsxIdFQiF2UXiYsdePVjY3pwZu37Pf8yR3p2QAg';

    let viewer;
    let tileset;
    let neighborhoodsDataSource = null;
    let neighborhoodsOutlineDataSource = null;
    let selectedNeighborhood = null;
    let redliningDataSource = null;
    let selectedFeature = null;
    let hotspotsDataSource = null;
    let rotationActive = false;
    let rotationListener = null;
    let rotationTimeout = null;

    const gradeColors = {
      'A': Cesium.Color.fromCssColorString('#76a865').withAlpha(0.4),
      'B': Cesium.Color.fromCssColorString('#7cb5bd').withAlpha(0.4),
      'C': Cesium.Color.fromCssColorString('#ffff00').withAlpha(0.4),
      'D': Cesium.Color.fromCssColorString('#d9838d').withAlpha(0.4),
      'Other': Cesium.Color.fromCssColorString('#808080').withAlpha(0.4)
    };

    const entitiesByGrade = { 'A': [], 'B': [], 'C': [], 'D': [], 'Other': [] };
    const visibleGrades = { 'A': true, 'B': true, 'C': true, 'D': true, 'Other': false };

    /**
     * Initialize the Cesium viewer and load Google 3D tiles
     */
    Cesium.createWorldTerrainAsync()
      .then(terrainProvider => {
        // Create Cesium viewer with minimal UI
        viewer = new Cesium.Viewer('cesiumContainer', {
          baseLayerPicker: false,
          timeline: false,
          animation: false,
          infoBox: false,
          selectionIndicator: false,
          terrainProvider: terrainProvider
        });

        // Set globe background to black
        viewer.scene.globe.baseColor = Cesium.Color.BLACK;

        // Increase request parallelization for Google tiles (if supported)
        try {
          if (Cesium.RequestScheduler && Cesium.RequestScheduler.requestsByServer) {
            Cesium.RequestScheduler.requestsByServer["tile.googleapis.com:443"] = 18;
          }
        } catch (e) {
          console.warn('Could not set RequestScheduler.requestsByServer:', e);
        }
        // Load Google Photorealistic 3D Tiles
        return Cesium.Cesium3DTileset.fromUrl(
          'https://tile.googleapis.com/v1/3dtiles/root.json?key=AIzaSyBiAU9yNxKyMgc48aRzspTOksmm1Vgitx4'
        );
      })
      .then(loadedTileset => {
        // Add tileset to the scene
        tileset = viewer.scene.primitives.add(loadedTileset);

        // Fly camera to Trenton, NJ with specified view
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(-74.8,  40.20, 1500),
          orientation: {
            heading: Cesium.Math.toRadians(50),
            pitch: Cesium.Math.toRadians(-20)
          },
          duration: 2
        });

        // Setup click handler for neighborhood selection
        viewer.screenSpaceEventHandler.setInputAction(function handle_LEFT_CLICK(click) {
          // If auto-rotating, stop on the next click
          if (rotationActive) {
            stopAutoRotate();
          }
          const pickedObject = viewer.scene.pick(click.position);
          
          if (!Cesium.defined(pickedObject)) {
            clearRedliningSelection();
            clearNeighborhoodSelection();
            closeFeaturePopup();
            return;
          }

          if (!Cesium.defined(pickedObject.id)) {
            clearRedliningSelection();
            clearNeighborhoodSelection();
            closeFeaturePopup();
            return;
          }

          const picked = pickedObject.id;

          // Handle redlining selection
          if (Cesium.defined(picked.gradeValue)) {
            if (selectedFeature && selectedFeature !== picked) {
              clearRedliningSelection();
            }
            if (selectedNeighborhood) {
              clearNeighborhoodSelection();
            }
            isolateFeature(picked);
            openFeaturePopup(picked, 'redlining');
            try {
              flyToEntity(picked, { duration: 1.2, pitch: Cesium.Math.toRadians(-30), heading: Cesium.Math.toRadians(0), minRange: 400 });
            } catch (e) {
              console.warn('FlyTo failed for redlining feature:', e);
            }
            return;
          }

          // Handle neighborhood selection
          if (picked.isNeighborhood) {
            if (selectedNeighborhood && selectedNeighborhood !== picked) {
              clearNeighborhoodSelection();
            }
            if (selectedFeature) {
              clearRedliningSelection();
            }
            isolateNeighborhood(picked);
            openFeaturePopup(picked, 'neighborhood');
            try {
              flyToEntity(picked, { duration: 1.2, pitch: Cesium.Math.toRadians(-35), heading: Cesium.Math.toRadians(0), minRange: 500 });
            } catch (e) {
              console.warn('FlyTo failed for neighborhood feature:', e);
            }
            return;
          }

          // Handle hotspots selection
          if (picked.isHotspot) {
            openFeaturePopup(picked, 'hotspot');
            try {
              flyToEntity(picked, { duration: 1.2, pitch: Cesium.Math.toRadians(-25), heading: Cesium.Math.toRadians(0), minRange: 200 });
              // Start auto-rotate shortly after the zoom completes
              if (rotationTimeout) {
                clearTimeout(rotationTimeout);
              }
              rotationTimeout = setTimeout(() => {
                startAutoRotate(picked, { speed: 0.25 });
              }, 1400);
            } catch (e) {
              console.warn('FlyTo failed for hotspot feature:', e);
            }
            return;
          }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        /**
         * Load redlining GeoJSON
         */
        Cesium.GeoJsonDataSource.load('./data/redlining.geojson', {
          clampToGround: true
        }).then(function(dataSource) {
          viewer.dataSources.add(dataSource);
          redliningDataSource = dataSource;

          dataSource.entities.values.forEach(function(entity) {
            if (Cesium.defined(entity.polygon)) {
              // Get grade property
              const gradeValue = entity.properties.grade ? entity.properties.grade.getValue() : null;
              const grade = gradeValue || 'Other';
              const color = gradeColors[grade] || Cesium.Color.GRAY.withAlpha(0.4);

              entity.polygon.material = color;
              entity.polygon.outline = true;
              entity.polygon.outlineColor = color.withAlpha(0.8);
              
              // Drape over both terrain and 3D buildings
              entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
              
              // Store grade for click detection
              entity.gradeValue = grade;
              
              // Store entity by grade for filtering
              if (entitiesByGrade[grade]) {
                entitiesByGrade[grade].push(entity);
              }
            }
          });

          // Hide Other grade entities by default
          entitiesByGrade['Other'].forEach(entity => {
            entity.show = false;
          });

          // Hide redlining data source by default
          dataSource.show = false;
        }).catch(error => {
          console.error('Error loading redlining layer:', error);
        });

        /**
         * Load neighborhoods GeoJSON - Fill layer
         */
        Cesium.GeoJsonDataSource.load('./data/neighborhoods.geojson', {
          clampToGround: true
        }).then(function(dataSource) {
          viewer.dataSources.add(dataSource);
          neighborhoodsDataSource = dataSource;
          
          dataSource.entities.values.forEach(function(entity) {
            if (Cesium.defined(entity.polygon)) {
              entity.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(1.0);
              entity.polygon.outlineWidth = 3;
              entity.polygon.fill = true;
              entity.polygon.material = Cesium.Color.fromCssColorString('#808080').withAlpha(0.0);
              entity.polygon.outline = true;
              entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
              entity.isNeighborhood = true;
              if (entity.properties.Neighborho) {
                entity.neighborhoodName = entity.properties.Neighborho.getValue();
              }
            }
          });
          // Hide neighborhoods fill layer by default
          dataSource.show = false;
        }).catch(error => {
          console.error('Error loading neighborhoods fill layer:', error);
        });

        /**
         * Load neighborhoods GeoJSON - Outline layer
         */
        Cesium.GeoJsonDataSource.load('./data/neighborhoods.geojson', {
          clampToGround: true
        }).then(function(dataSource) {
          viewer.dataSources.add(dataSource);
          neighborhoodsOutlineDataSource = dataSource;
          
          dataSource.entities.values.forEach(function(entity) {
            if (Cesium.defined(entity.polygon)) {
              entity.polygon.fill = false;
              entity.polygon.outline = true;
              entity.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(1.0);
              entity.polygon.outlineWidth = 3;
              entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
              entity.isNeighborhood = true;
              if (entity.properties.Neighborho) {
                entity.neighborhoodName = entity.properties.Neighborho.getValue();
              }
            }
          });
          // Hide neighborhoods outline layer by default
          dataSource.show = false;
        }).catch(error => {
          console.error('Error loading neighborhoods outline layer:', error);
        });

        /**
         * Load hotspots_pg GeoJSON with extrusion
         */
        Cesium.GeoJsonDataSource.load('./data/hotspots_pg.geojson?t=' + Date.now(), {
          clampToGround: false
        }).then(function(dataSource) {
          viewer.dataSources.add(dataSource);
          hotspotsDataSource = dataSource;

          dataSource.entities.values.forEach(function(entity) {
            if (Cesium.defined(entity.polygon)) {
              // Get extrusion height from extru_ele_m property
              const extrusionHeight = entity.properties.extru_ele_m ? entity.properties.extru_ele_m.getValue() : 75;
              console.log('Hotspot:', entity.properties.name.getValue(), 'Extrusion height:', extrusionHeight);
              
              // Set polygon properties
              entity.polygon.material = Cesium.Color.fromCssColorString('#66BB6A').withAlpha(0.4);
              entity.polygon.outline = true;
              entity.polygon.outlineColor = Cesium.Color.fromCssColorString('#b300ff');
              entity.polygon.outlineWidth = 5;
              entity.polygon.extrudedHeight = extrusionHeight;
              entity.polygon.height = -35;
              
              // Mark as hotspot for click detection
              entity.isHotspot = true;
              if (entity.properties.name) {
                entity.hotspotName = entity.properties.name.getValue();
              }
            }
          });
          
          // Show hotspots by default
          dataSource.show = true;
        }).catch(error => {
          console.error('Error loading hotspots layer:', error);
        });
      })
      .catch(error => {
        console.error('Error initializing viewer:', error);
      });

    /**
     * Toggle Google 3D Tiles layer visibility
     */
    document.getElementById('toggleGoogle3D').addEventListener('change', e => {
      if (tileset) {
        tileset.show = e.target.checked;
      }
    });

    /**
     * Toggle neighborhoods layers visibility
     */
    document.getElementById('toggleNeighborhoods').addEventListener('change', e => {
      if (neighborhoodsDataSource) {
        neighborhoodsDataSource.show = e.target.checked;
      }
      if (neighborhoodsOutlineDataSource) {
        neighborhoodsOutlineDataSource.show = e.target.checked;
      }
    });

    /**
     * Toggle hotspots layer visibility
     */
    document.getElementById('toggleHotspots').addEventListener('change', e => {
      if (hotspotsDataSource) {
        hotspotsDataSource.show = e.target.checked;
      }
    });

    /**
     * Toggle redlining layer visibility
     */
    document.getElementById('toggleRedlining').addEventListener('change', e => {
      if (redliningDataSource) {
        redliningDataSource.show = e.target.checked;
      }
    });

    /**
     * Toggle individual redlining grades visibility
     */
    document.querySelectorAll('[id^="toggleGrade"]').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        e.stopPropagation();
        const grade = e.target.dataset.grade;
        visibleGrades[grade] = e.target.checked;

        // Update entity visibility for this grade
        entitiesByGrade[grade].forEach(entity => {
          entity.show = visibleGrades[grade];
        });
      });
    });

    /**
     * Sneak peek - show/hide layers on hover
     */
    // Neighborhoods layer sneak peek
    const neighborhoodsLabel = document.querySelector('label[for="toggleNeighborhoods"]')?.parentElement || 
                                document.querySelector('label:has(#toggleNeighborhoods)');
    if (neighborhoodsLabel) {
      neighborhoodsLabel.addEventListener('mouseenter', () => {
        if (neighborhoodsDataSource) neighborhoodsDataSource.show = !neighborhoodsDataSource.show;
        if (neighborhoodsOutlineDataSource) neighborhoodsOutlineDataSource.show = !neighborhoodsOutlineDataSource.show;
      });
      neighborhoodsLabel.addEventListener('mouseleave', () => {
        if (neighborhoodsDataSource) neighborhoodsDataSource.show = document.getElementById('toggleNeighborhoods').checked;
        if (neighborhoodsOutlineDataSource) neighborhoodsOutlineDataSource.show = document.getElementById('toggleNeighborhoods').checked;
      });
    }

    // Hotspots layer sneak peek
    const hotspotsLabel = document.querySelector('label[for="toggleHotspots"]')?.parentElement || 
                          document.querySelector('label:has(#toggleHotspots)');
    if (hotspotsLabel) {
      hotspotsLabel.addEventListener('mouseenter', () => {
        if (hotspotsDataSource) hotspotsDataSource.show = !hotspotsDataSource.show;
      });
      hotspotsLabel.addEventListener('mouseleave', () => {
        if (hotspotsDataSource) hotspotsDataSource.show = document.getElementById('toggleHotspots').checked;
      });
    }

    // Redlining layer sneak peek
    const redliningLabel = document.querySelector('label[for="toggleRedlining"]')?.parentElement || 
                           document.querySelector('label:has(#toggleRedlining)');
    if (redliningLabel) {
      redliningLabel.addEventListener('mouseenter', () => {
        if (redliningDataSource) redliningDataSource.show = !redliningDataSource.show;
      });
      redliningLabel.addEventListener('mouseleave', () => {
        if (redliningDataSource) redliningDataSource.show = document.getElementById('toggleRedlining').checked;
      });
    }

    // Grade toggles sneak peek
    document.querySelectorAll('[id^="toggleGrade"]').forEach(checkbox => {
      const label = checkbox.parentElement;
      label.addEventListener('mouseenter', () => {
        const grade = checkbox.dataset.grade;
        const currentState = checkbox.checked;
        entitiesByGrade[grade].forEach(entity => {
          entity.show = !currentState;
        });
      });
      label.addEventListener('mouseleave', () => {
        const grade = checkbox.dataset.grade;
        entitiesByGrade[grade].forEach(entity => {
          entity.show = visibleGrades[grade];
        });
      });
    });

    /**
     * Open feature popup with details
     */
    function openFeaturePopup(feature, featureType) {
      let title = '';
      let content = '';

      try {
        if (featureType === 'hotspot') {
          // Hotspots popup - show name, type, theme, time period, height, link
          title = feature.hotspotName || 'Hotspot';
          const name = feature.properties.name ? feature.properties.name.getValue() : '';
          const type = feature.properties.type ? feature.properties.type.getValue() : '';
          const theme = feature.properties.theme ? feature.properties.theme.getValue() : '';
          const timePeriod = feature.properties.time_period ? feature.properties.time_period.getValue() : '';
          const height = feature.properties.extru_ele_m ? feature.properties.extru_ele_m.getValue() : '';
          const link = feature.properties.link ? feature.properties.link.getValue() : '';
          
          content = `
            <p><strong>Type:</strong> ${type}</p>
            <p><strong>Theme:</strong> ${theme}</p>
            <p><strong>Time Period:</strong> ${timePeriod}</p>
            <p><strong>Height:</strong> ${height} m</p>
            ${link ? `<p><a href="${link}" target="_blank" style="color: #4fc3f7; text-decoration: underline;">View Content</a></p>` : ''}
          `;
        } else if (featureType === 'neighborhood') {
          // Neighborhoods popup - show neighborhood name and area in acres
          title = feature.neighborhoodName || 'Neighborhood';
          
          // Get area from properties - try different property names
          let shapeAreaMeters = 0;
          if (feature.properties) {
            // Try accessing through the properties object
            if (feature.properties.Shape_Area && feature.properties.Shape_Area.getValue) {
              shapeAreaMeters = parseFloat(feature.properties.Shape_Area.getValue());
            } else if (feature.properties.Shape__Are && feature.properties.Shape__Are.getValue) {
              shapeAreaMeters = parseFloat(feature.properties.Shape__Are.getValue());
            }
          }
          
          const shapeAreaAcres = (shapeAreaMeters / 4046.86).toFixed(2);
          
          content = `
            ${shapeAreaAcres > 0 ? `<p><strong>Area:</strong> ${shapeAreaAcres} acres</p>` : '<p>Area: not available</p>'}
          `;
        } else if (featureType === 'redlining') {
          // Redlining popup - show grade, category, location, zoning details
          const grade = feature.gradeValue;
          const gradeNames = {
            'A': 'Best',
            'B': 'Still Desirable',
            'C': 'Declining',
            'D': 'Hazardous',
            'Other': 'Commercial/Industrial'
          };
          title = `HOLC Grade: ${grade}`;

          // Read raw properties (some are stored as underscored fields)
          const category = (feature._category && feature._category !== '') ? feature._category : (feature.properties && feature.properties.category && feature.properties.category.getValue ? feature.properties.category.getValue() : '');
          const city = (feature._city && feature._city !== '') ? feature._city : (feature.properties && feature.properties.city && feature.properties.city.getValue ? feature.properties.city.getValue() : '');
          const state = (feature._state && feature._state !== '') ? feature._state : (feature.properties && feature.properties.state && feature.properties.state.getValue ? feature.properties.state.getValue() : '');
          const label = (feature._label && feature._label !== '') ? feature._label : (feature.properties && feature.properties.label && feature.properties.label.getValue ? feature.properties.label.getValue() : '');

          // Booleans: some fields may be true/false or missing
          const residentialFlag = (feature._residentia !== undefined) ? feature._residentia : (feature.properties && feature.properties.residentia && feature.properties.residentia.getValue ? feature.properties.residentia.getValue() : null);
          const commercialFlag = (feature._commercial !== undefined) ? feature._commercial : (feature.properties && feature.properties.commercial && feature.properties.commercial.getValue ? feature.properties.commercial.getValue() : null);
          const industrialFlag = (feature._industrial !== undefined) ? feature._industrial : (feature.properties && feature.properties.industrial && feature.properties.industrial.getValue ? feature.properties.industrial.getValue() : null);

          const categoryDisplay = category && category !== '' ? category : 'Not available';
          const locationDisplay = (city || state) ? `${city || ''}${city && state ? ', ' : ''}${state || ''}` : 'Not available';
          const labelDisplay = label && label !== '' ? label : 'Not available';
          const residential = residentialFlag ? 'Yes' : 'No';
          const commercial = commercialFlag ? 'Yes' : 'No';
          const industrial = industrialFlag ? 'Yes' : 'No';

          content = `
            <p><strong>Category:</strong> ${categoryDisplay}</p>
            <p><strong>Location:</strong> ${locationDisplay}</p>
            <p><strong>Label:</strong> ${labelDisplay}</p>
            <p><strong>Residential:</strong> ${residential}</p>
            <p><strong>Commercial:</strong> ${commercial}</p>
            <p><strong>Industrial:</strong> ${industrial}</p>
          `;
        }

        // Update popup content
        document.getElementById('popupTitle').textContent = title;
        document.getElementById('popupContent').innerHTML = content;
        document.getElementById('featurePopup').classList.add('visible');

        // Store current feature type for closing
        document.getElementById('featurePopup').dataset.featureType = featureType;
      } catch (error) {
        console.error('Error opening feature popup:', error);
        console.log('Feature object:', feature);
      }
    }

    /**
     * Close feature popup and deselect feature
     */
    function closeFeaturePopup() {
      const popup = document.getElementById('featurePopup');
      popup.classList.remove('visible');
      
      const featureType = popup.dataset.featureType;
      if (featureType === 'neighborhood') {
        clearNeighborhoodSelection();
      } else if (featureType === 'redlining') {
        clearRedliningSelection();
      }
      // For hotspots, no selection state to clear yet
    }

    // Close popup button click handler
    document.getElementById('closePopupBtn').addEventListener('click', closeFeaturePopup);

    /**
     * Isolate a selected neighborhood by darkening unselected ones
     */
    function isolateNeighborhood(neighborhood) {
      selectedNeighborhood = neighborhood;
      
      if (neighborhoodsDataSource) {
        neighborhoodsDataSource.entities.values.forEach(entity => {
          if (entity === neighborhood) {
            // Selected neighborhood: transparent
            entity.polygon.material = Cesium.Color.fromCssColorString('#000000').withAlpha(0);
          } else {
            // Unselected neighborhoods: darkened
            entity.polygon.material = Cesium.Color.fromCssColorString('#000000').withAlpha(0.8);
          }
        });
      }
    }

    /**
     * Clear neighborhood selection and restore original styling
     */
    function clearNeighborhoodSelection() {
      if (neighborhoodsDataSource) {
        neighborhoodsDataSource.entities.values.forEach(entity => {
          if (entity.isNeighborhood) {
            // Restore original styling
            entity.polygon.material = Cesium.Color.fromCssColorString('#808080').withAlpha(0.0);
          }
        });
      }
      selectedNeighborhood = null;
    }

    /**
     * Isolate a selected redlining feature by darkening unselected ones
     */
    function isolateFeature(feature) {
      selectedFeature = feature;
      
      // Dim all redlining entities except the selected one
      if (redliningDataSource) {
        redliningDataSource.entities.values.forEach(entity => {
          if (entity === feature) {
            entity.show = true;
            // Keep original color for selected feature
          } else {
            // Dim non-selected features with dark gray transparent material
            entity.polygon.material = Cesium.Color.fromCssColorString('#000000').withAlpha(0.8);
            entity.polygon.outlineColor = Cesium.Color.fromCssColorString('#222222').withAlpha(0.5);
            entity.show = true;
          }
        });
      }
    }

    /**
     * Clear redlining selection and restore original styling
     */
    function clearRedliningSelection() {
      if (redliningDataSource) {
        redliningDataSource.entities.values.forEach(entity => {
          if (Cesium.defined(entity.gradeValue)) {
            // Restore original grade color
            const grade = entity.gradeValue;
            const color = gradeColors[grade] || Cesium.Color.GRAY.withAlpha(0.4);
            entity.polygon.material = color;
            entity.polygon.outlineColor = color.withAlpha(0.8);
          }
        });
      }
      selectedFeature = null;
    }

    /**
     * Compute a bounding sphere for an entity (polygons or points) to allow
     * camera.flyToBoundingSphere to focus tightly on selected features.
     */
    function getBoundingSphereForEntity(entity) {
      try {
        // Polygon hierarchy (GeoJSON polygons)
        if (entity.polygon && entity.polygon.hierarchy) {
          const jd = Cesium.JulianDate.now();
          const hierarchyValue = (typeof entity.polygon.hierarchy.getValue === 'function') ? entity.polygon.hierarchy.getValue(jd) : entity.polygon.hierarchy;
          const positions = hierarchyValue && hierarchyValue.positions ? hierarchyValue.positions : hierarchyValue;
          if (positions && positions.length) {
            return Cesium.BoundingSphere.fromPoints(positions);
          }
        }

        // Point-like entity
        if (entity.position) {
          const jd = Cesium.JulianDate.now();
          const pos = (typeof entity.position.getValue === 'function') ? entity.position.getValue(jd) : entity.position;
          if (pos) {
            return new Cesium.BoundingSphere(pos, 50.0);
          }
        }
      } catch (e) {
        console.warn('Error computing bounding sphere:', e);
      }
      return null;
    }

    /**
     * Fly the camera to an entity using a bounding-sphere-based offset when possible.
     * Falls back to viewer.flyTo if necessary.
     */
    function flyToEntity(entity, options) {
      options = options || {};
      const duration = (typeof options.duration !== 'undefined') ? options.duration : 1.2;
      const pitch = (typeof options.pitch !== 'undefined') ? options.pitch : Cesium.Math.toRadians(-30);
      const heading = (typeof options.heading !== 'undefined') ? options.heading : Cesium.Math.toRadians(0);

      const bs = getBoundingSphereForEntity(entity);
      if (bs) {
        // Use a multiplier so the feature is comfortably framed
        const minRange = (typeof options.minRange !== 'undefined') ? options.minRange : 400;
        const range = Math.max(bs.radius * 2.5, minRange);
        try {
          viewer.camera.flyToBoundingSphere(bs, {
            duration: duration,
            offset: new Cesium.HeadingPitchRange(heading, pitch, range)
          });
          return;
        } catch (e) {
          console.warn('flyToBoundingSphere failed, falling back to viewer.flyTo:', e);
        }
      }

      // Fallback
      try {
        viewer.flyTo(entity, {
          duration: duration,
          offset: new Cesium.HeadingPitchRange(heading, pitch, options.fallbackRange || 800)
        });
      } catch (e) {
        console.warn('Fallback flyTo failed:', e);
      }
    }

    /**
     * Start auto-rotating the camera around an entity. Rotation continues
     * until `stopAutoRotate()` is called (for example, by another click or closing popup).
     * Options: { speed: radiansPerSec }
     */
    function startAutoRotate(entity, options) {
      if (!viewer || !entity) return;
      options = options || {};
      const speed = (typeof options.speed === 'number') ? options.speed : 0.25; // radians/sec

      // Ensure any existing rotation is stopped
      stopAutoRotate();

      // Compute bounding sphere and transform for local ENU frame
      const bs = getBoundingSphereForEntity(entity);
      if (!bs) return;
      const center = bs.center;
      const range = Math.max(bs.radius * 2.2, options.minRange || 200);
      const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);

      // Base offset in local ENU coordinates: (x, y, z)
      const baseOffset = new Cesium.Cartesian3(range, 0.0, range * 0.25);

      let angle = 0.0;
      let lastTime = performance.now();

      rotationListener = function(scene, time) {
        const now = performance.now();
        const dt = (now - lastTime) / 1000.0;
        lastTime = now;
        angle += dt * speed;

        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const rotated = new Cesium.Cartesian3(
          baseOffset.x * c - baseOffset.y * s,
          baseOffset.x * s + baseOffset.y * c,
          baseOffset.z
        );

        // Use lookAtTransform so the offset is interpreted in the ENU frame at the center
        try {
          viewer.camera.lookAtTransform(transform, rotated);
        } catch (e) {
          console.warn('Auto-rotate camera update failed:', e);
        }
      };

      viewer.scene.preRender.addEventListener(rotationListener);
      rotationActive = true;
    }

    /**
     * Stop any active auto-rotation and restore the camera control to the user.
     */
    function stopAutoRotate() {
      if (!viewer) return;
      if (rotationTimeout) {
        clearTimeout(rotationTimeout);
        rotationTimeout = null;
      }
      if (rotationListener) {
        try {
          viewer.scene.preRender.removeEventListener(rotationListener);
        } catch (e) {
          // ignore
        }
        rotationListener = null;
      }
      if (rotationActive) {
        try {
          viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        } catch (e) {
          // ignore
        }
      }
      rotationActive = false;
    }

    /**
     * Reset the camera to the default Trenton overview and clear any selection/rotation.
     */
    function resetView() {
      // Stop rotation and close popup/clear selections
      stopAutoRotate();
      closeFeaturePopup();
      clearNeighborhoodSelection();
      clearRedliningSelection();

      // Fly camera back to the initial overview position
      try {
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(-74.8,  40.20, 1500),
          orientation: {
            heading: Cesium.Math.toRadians(50),
            pitch: Cesium.Math.toRadians(-20)
          },
          duration: 1.6
        });
      } catch (e) {
        console.warn('Reset view flyTo failed:', e);
      }
    }

    // Reset view button handler
    document.getElementById('resetViewBtn').addEventListener('click', resetView);
  </script>
  </body>
</html>
